  // A.1 Lexical Grammar

  // input characters are represented as ES3 characters, which can be any unicode character
  SourceCharacter = char,

  // 7: Goal production in contexts where a leading '/' or '/=' is permitted
  // Note: not used by the parser
  InputElementDiv = Whitespace || LineTerminator || Comment || Token || DivPunctuator,

  // 7: Goal production in contexts where a leading '/' or '/=' is not permitted
  // Note: not used by the parser
  InputElementRegExp = Whitespace || LineTerminator || Comment || Token || RegularExpressionLiteral,

  // Note: not currently used by the parser
  Token = IdentifierName || Punctuator || NumericLiteral || StringLiteral,

  Whitespace = uc('SP') || uc('TAB') || uc('VT') || uc('FF') || uc('NBSP') || uc('BOM') || uc('Zs'),
  LineTerminator = uc('LF') || uc('CR') || uc('LS') || uc('PS'),
  LineTerminatorSequence = uc('LF') || ~uc('LF') uc('CR') || uc('LS') || uc('PS') || uc('CR') uc('LF'),

  Comment = MultiLineComment || SingleLineComment,

  // <...> is OMeta's "consumed-by" operator: the value of <...> is the input it consumed
  MultiLineComment = seq("/*") <(MultiLineCommentChars | empty)>:cs seq("*/") -> cs,
  MultiLineCommentChars = MultiLineNotAsteriskChar (MultiLineCommentChars | empty)
                       || '*' (PostAsteriskCommentChars | &seq("*/")),
  PostAsteriskCommentChars = MultiLineNotForwardSlashOrAsteriskChar (MultiLineCommentChars | empty)
                          || '*' (PostAsteriskCommentChars | &seq("*/")),
  MultiLineNotAsteriskChar = ~('*') SourceCharacter,
  MultiLineNotForwardSlashOrAsteriskChar = ~('/' || '*') SourceCharacter,
  SingleLineComment = seq("//") <(SingleLineCommentChars | empty)>,
  SingleLineCommentChars = SingleLineCommentChar (SingleLineCommentChars | empty),
  SingleLineCommentChar = ~LineTerminator SourceCharacter,

  Identifier = IdentifierName:n ~checkReservedWord(n) -> (n),
  IdentifierName = <IdentifierName IdentifierPart>
                 | IdentifierStart,

  IdentifierStart = UnicodeLetter || '$' || '_' || '\\' UnicodeEscapeSequence,
  IdentifierPart = IdentifierStart | UnicodeCombiningMark
                 | UnicodeDigit | UnicodeConnectorPunctuation
                 | uc('ZWNJ') | uc('ZWJ'),
  UnicodeLetter = uc('L') || uc('Nl'),
  UnicodeCombiningMark = uc('Mn') || uc('Mc'),
  UnicodeDigit = uc('Nd'),
  UnicodeConnectorPunctuation = uc('Pc'),

  checkReservedWord :id = ?(this.isKeyword(id) || this.isFutureReservedWord(id) ||
                            id == "null" || id == "true" || id == "false") -> true,

  // ReservedWord = Keyword | FutureReservedWord(this.strictmode) | NullLiteral | BooleanLiteral,

  // Note: keywords that are the complete prefix of another keyword should
  // be prioritized (e.g. 'in' should come before 'instanceof')
  Keyword = (``break''   | ``do''        | ``instanceof'' | ``typeof''
          | ``case''     | ``else''      | ``new''        | ``var''
          | ``catch''    | ``finally''   | ``return''     | ``void''
          | ``continue'' | ``for''       | ``switch''     | ``while''
          | ``debugger'' | ``function''  | ``this''       | ``with''
          | ``default''  | ``if''        | ``throw''
          | ``delete''   | ``in''        | ``try''):kwname ~IdentifierPart -> kwname,

  FutureReservedWord false:strict = (``class''| ``enum''  | ``extends''
                                  | ``super'' |  ``const''| ``export''
                                  | ``import''):kwname ~IdentifierPart -> kwname,
  FutureReservedWord true:strict = (FutureReservedWord(false)
                                 |  ``implements''| ``let''    | ``private''  | ``public''
                                 |  ``interface'' | ``package''| ``protected''| ``static''
                                 |  ``yield''):kwname ~IdentifierPart -> kwname,

  // Note: beware of the ordering of punctuators with a common prefix!
  // OMeta is a PEG, so '|' denotes prioritized choice.
  // E.g. if '+' would come before ``++'' then the string "++5"
  // would be parsed as "+(+(5))" rather than "++(5)"
  // Punctuators comprised of more characters are prioritized
  // Note: the Punctuator and DivPunctuator rules are not currently used by the parser
  Punctuator = (``>>>=''
             | ``>>='' | ``>>>'' | ``==='' | ``!==''| ``<<=''
             | ``+=''  | ``-=''  | ``*=''  | ``%='' | ``>=''
             | ``==''  | ``!=''  | ``++''  | ``--'' | ``<<''
             | ``>>''  | ``<=''  | ``&=''  | ``|='' | ``^=''
             | ``&&''  | ``||''
             | '{'     | '}'     | '('     | ')'    | '['   | ']'
             | '.'     | ';'     | ','     | '<'    | '>'   | '!'
             | '~'     | '='     | '&'     | '|'    | '^'   | '?'
             | ':'     | '*'     | '%'     | '+'    | '-'),
  DivPunctuator = (``/='' | '/'),

  // Punctuators partitioned according to length (for optimization purposes only)
  // Not used because performance gain was marginal (~3% faster)
  /*
  Punctuator4 = ``>>>='',
  Punctuator3 = ``>>='' | (``>>>'':s ~'=' -> s) | ``==='' | ``!==''| ``<<='',
  Punctuator2 = ``+=''  | ``-=''  | ``*=''  | ``%='' | ``>=''
              |  (``=='':s ~'='->s)  | (``!='':s ~'='->s)  | ``++''  | ``--'' | (``<<'':s ~'='->s)
              |  (``>>'':s ~'='->s)  | ``<=''  | ``&=''  | ``|='' | ``^=''
              |  ``&&''  | ``||''  | ``/='',
  Punctuator1 = '{'     | '}'     | '('     | ')'    | '['   | ']'
              | '.'     | ';'     | ','     | ('<':s ~('<'|'=')->s)  | ('>':s ~('>'|'=')->s) | ('!':s ~'='->s)
              | ('~':s ~'='->s)   | ('=':s ~'='->s)  | ('&':s ~'='->s) | ('|':s ~'='->s) | ('^':s ~'='->s) | '?'
              | ':'     | ('*':s ~'='->s)   | ('%':s ~'='->s)     | ('+':s ~('+'|'=')->s) | ('-':s ~('-'|'=')->s) | ('/':s ~'='->s),*/

  Literal = NullLiteral || BooleanLiteral || NumericLiteral
          || StringLiteral || RegularExpressionLiteral, // spec forgot Regexp literals in appendix?
  NullLiteral = ``null'' -> literal("null", null),
  BooleanLiteral = (``true'' -> true || ``false'' -> false):b -> literal("boolean",b),

  // For semantics on how decimal literals are constructed, see section 7.8.3

  // Note that the ordering of HexIntegerLiteral and DecimalLiteral is reversed w.r.t. the spec
  // This is intentional: the order DecimalLiteral | HexIntegerLiteral will parse
  // '0x...' as a decimal literal '0' followed by 'x...'
  NumericLiteral = (HexIntegerLiteral | DecimalLiteral):l -> literal("number",l),

  // DecimalDigits produces objects of the form {val: aNumber, len: aNumber }
  // The 'len' attribute describes the number of characters in the parsed numeral
  // This is required for interpreting fractional literals
  // Note: no exclusive choice, e.g. the input '5.5' will satisfy
  // both rules #1 and #3 (even though #3 only eats '5')
  DecimalLiteral = DecimalIntegerLiteral:l '.'
                     (DecimalDigits | empty -> {val:0,len:0}):d (ExponentPart | empty -> 0):e ->
                     ( (l + (d.val * Math.pow(10,-d.len))) * Math.pow(10,e) )
                 | '.' DecimalDigits:d (ExponentPart | empty -> 0):e ->
                     ( (d.val * Math.pow(10, -d.len)) * Math.pow(10,e) )
                 | DecimalIntegerLiteral:l (ExponentPart | empty -> 0):e ->
                     ( l * Math.pow(10,e) ),

  DecimalIntegerLiteral = NonZeroDigit:z (DecimalDigits | empty -> {val:0,len:0}):d ->
                          ( (z * Math.pow(10,d.len)) + d.val )
                        || '0'->0,
  DecimalDigits = DecimalDigits:ds DecimalDigit:d -> ({ val: (ds.val * 10 + d), len: ds.len+1 })
                | DecimalDigit:d -> ({val: d, len: 1}),
  DecimalDigit = '0'->0 || '1'->1 || '2'->2 || '3'->3 || '4'->4 || '5'->5 || '6'->6 || '7'->7 || '8'->8 || '9'->9,
  NonZeroDigit = '1'->1 || '2'->2 || '3'->3 || '4'->4 || '5'->5 || '6'->6 || '7'->7 || '8'->8 || '9'->9,

  ExponentPart = ExponentIndicator SignedInteger:si -> si,
  ExponentIndicator = 'e' || 'E',
  SignedInteger = DecimalDigits:ds -> (ds.val)
                || '+' DecimalDigits:ds -> (ds.val)
                || '-' DecimalDigits:ds -> (-(ds.val)),

  HexIntegerLiteral = HexIntegerLiteral:l HexDigit:d -> ( (l * 16) + d )
                    | ``0x'' HexDigit:d -> d
                    | ``0X'' HexDigit:d -> d,
  HexDigit = '0'->0 || '1'->1 || '2'->2 || '3'->3 || '4'->4 || '5'->5 || '6'->6 || '7'->7 || '8'->8 || '9'->9
           || 'a'->10 || 'b'->11 || 'c'->12 || 'd'->13 || 'e'->14 || 'f'->15
           || 'A'->10 || 'B'->11 || 'C'->12 || 'D'->13 || 'E'->14 || 'F'->15,

  // For semantics on how string literals are constructed, see section 7.8.4
  StringLiteral = '"' (DoubleStringCharacters | empty -> ""):s '"' -> (literal("string",s))
                || '\'' (SingleStringCharacters | empty -> ""):s '\'' -> (literal("string",s)),
  DoubleStringCharacters = DoubleStringCharacter:c (DoubleStringCharacters | empty -> ""):cs ->
                           ( c.concat(cs) ),
  SingleStringCharacters = SingleStringCharacter:c (SingleStringCharacters | empty -> ""):cs ->
                           ( c.concat(cs) ),
  DoubleStringCharacter = ~('"' || '\\' || LineTerminator) SourceCharacter:s -> (s)
                        || '\\' EscapeSequence:s -> (s)
                        || LineContinuation,
  SingleStringCharacter = ~('\'' || '\\' || LineTerminator) SourceCharacter:s -> (s)
                        || '\\' EscapeSequence:s -> (s)
                        || LineContinuation,
  LineContinuation = '\\' LineTerminatorSequence -> (""),
  EscapeSequence = CharacterEscapeSequence
                 || ~DecimalDigit '0' -> ( String.fromCharCode(0000) ) /*\u0000*/
                 || HexEscapeSequence
                 || UnicodeEscapeSequence,
  CharacterEscapeSequence = SingleEscapeCharacter
                          || NonEscapeCharacter,
  SingleEscapeCharacter = '\''  -> ( String.fromCharCode(0039) ) /*\u0027*/
                        || '"'  -> ( String.fromCharCode(0034) ) /*\u0022*/
                        || '\\' -> ( String.fromCharCode(0092) ) /*\u005C*/
                        || 'b'  -> ( String.fromCharCode(0008) ) /*\u0008*/
                        || 'f'  -> ( String.fromCharCode(0012) ) /*\u000C*/
                        || 'n'  -> ( String.fromCharCode(0010) ) /*\u000A*/
                        || 'r'  -> ( String.fromCharCode(0013) ) /*\u000D*/
                        || 't'  -> ( String.fromCharCode(0009) ) /*\u0009*/
                        || 'v'  -> ( String.fromCharCode(0011) ) /*\u000B*/,
  NonEscapeCharacter = ~(EscapeCharacter || LineTerminator) SourceCharacter:s -> (s),
  EscapeCharacter = SingleEscapeCharacter || DecimalDigit || 'x' || 'u',
  HexEscapeSequence = 'x' HexDigit:a HexDigit:b -> ( String.fromCharCode(a*16+b) ),
  UnicodeEscapeSequence = 'u' HexDigit:a HexDigit:b HexDigit:c HexDigit:d ->
                              ( String.fromCharCode(a*4096 + b*256 + c*16 + d) ),

  // section 7.8.5

  // body and flags are left uninterpreted while parsing (they are parsed as strings)
  RegularExpressionLiteral = '/' RegularExpressionBody:b '/' RegularExpressionFlags:f ->
                             ( literal("regexp",{body:b,flags:f}) ),
  RegularExpressionBody = <RegularExpressionFirstChar RegularExpressionChars>,
  RegularExpressionChars = <RegularExpressionChars RegularExpressionChar>
                         | empty -> (""),
  RegularExpressionFirstChar = ~('*' ||'\\' || '/' || '[') RegularExpressionNonTerminator
                             || RegularExpressionBackslashSequence
                             || RegularExpressionClass,
  RegularExpressionChar = ~('\\' || '/' || '[') RegularExpressionNonTerminator
                        || RegularExpressionBackslashSequence
                        || RegularExpressionClass,
  RegularExpressionBackslashSequence = '\\' RegularExpressionNonTerminator,
  RegularExpressionNonTerminator = ~(LineTerminator) SourceCharacter,
  RegularExpressionClass = '[' RegularExpressionClassChars ']',
  RegularExpressionClassChars = RegularExpressionClassChars RegularExpressionClassChar
                              | empty -> (""),
  RegularExpressionClassChar = ~(']' || '\\') RegularExpressionNonTerminator
                             || RegularExpressionBackslashSequence,
  RegularExpressionFlags = <RegularExpressionFlags IdentifierPart>
                         | empty -> (""),



grammar = line*:l emptyline* end -> l

hspace    = ' ' | '\t'
vspace    = '\n'
optspace  = ?(self.parenthesis) (hspace | '\\'? vspace | comment)* | (hspace | '\\' vspace)* comment?
mandspace = ?(self.parenthesis) (hspace | '\\'? vspace | comment)+ | (hspace | '\\' vspace)+ comment?

indentation = hspace*:i ?(len(i) == self.indent_stack[-1])
indent      = hspace*:i ?(len(i) > self.indent_stack[-1]) !(self.indent_stack.append(len(i)))
dedent      = !(self.dedent())

comment  = '#' line_rest:c -> ['comment', c]
emptyline = hspace* ('\\' | comment)?:c vspace
block     = emptyline* indent stmt:s optspace (vspace | end) line*:l dedent -> [s] + l
line      = emptyline*:e indentation stmt:s optspace (vspace | end) -> s
line_rest = (~vspace :x)*:x -> ''.join(x)

stmt = pass | global | continue | break | return | raise | while
     | if | def | for | try | augassign | assign

global = "global" mandspace innercsv('name'):names -> ['global', names]

continue = "continue"              -> ['continue']
break    = "break"                 -> ['break']

pass   = "pass"                    -> ['pass']
return = "return" mandspace expr:e -> ['return', e]
raise  = "raise" mandspace expr:e  -> ['raise', e]

augassign = get:l optspace
            ("+=" | "-=" | "*=" | "/=" | "//=" | "%=" | "^=" | "&=" | "|=" | "~=" | "<<=" | ">>="):op
            optspace expr:r
            -> ['augassign', op, l, r]
assign = get:l optspace '=' optspace assign:r -> ['assign', l, r]
       | expr
expr = ifexpr
     | innerifexpr
innerifexpr = orop
orop  = orop:l optspace "or":op andop:r -> ['binop', op, l, r]
      | andop
andop = andop:l optspace "and":op notop:r -> ['binop', op, l, r]
      | notop
notop = optspace "not":op mandspace notop:r -> ['unop', op, r]
      | cmpop
comparison = ( "in"                 -> 'in'
             | "not" mandspace "in" -> 'not in'
             | "is" mandspace "not" -> 'is not'
             | "is"                 -> 'is'
             ):x mandspace -> x
           | "<" | "<=" | ">" | ">=" | "!=" | "=="
cmpop = cmpop:l optspace comparison:op optspace bitor:r -> ['binop', op, l, r]
      | bitor
bitor = bitor:l optspace '|':op bitxor:r -> ['binop', op, l, r]
      | bitxor
bitxor = bitxor:l optspace '^':op bitand:r -> ['binop', op, l, r]
      | bitand
bitand = bitand:l optspace '&':op shift:r -> ['binop', op, l, r]
      | shift
shift = shift:l optspace ("<<" | ">>"):op addop:r -> ['binop', op, l, r]
      | addop
addop = addop:l optspace ('+' | '-'):op mulop:r -> ['binop', op, l, r]
      | mulop
mulop = mulop:l optspace ('*' | '/' | '//' | '%'):op unop:r -> ['binop', op, l, r]
      | unop
unop  = optspace ('-' | '+' | '~'):op unop:e -> ['unop', op, e]
      | callable

callable = optspace
         ( new
         | lambda
         | deflambda
         | get
         )

get = get:obj optspace '.' optspace name:n        -> ['get', obj, n]
    | get:obj optspace '[' csv('expr'):elem ']'   -> ['getitem', obj, elem]
    | get:obj optspace '(' csv('expr'):params ')' -> ['call', obj, params]
    | immediate

immediate = number
          | string
          | list
          | tuple
          | dict
          | set
          | name
          | '(' !(self.enter_paren()) expr:ix optspace ')' !(self.leave_paren()) -> ix

new = "new" mandspace get:c -> ['new', c]

name_start   = letter | '$' | '_'
name_rest    = name_start | digit
iname        = name_start:s name_rest*:r   -> s + ''.join(r)
iskeyword :x = ?(self.is_keyword(x))
name         = iname:n ~iskeyword(n)       -> ['name', n]

escaped_char = '\\' :x -> ('\\' + x).decode('string_escape')
string3 :e = match_string(e) (escaped_char | ~(?(len(e) != 3) vspace | match_string(e)) anything)*:c match_string(e) -> ''.join(c)
string2 = string3('"""') | string3("'''") | string3('"') | string3("'")
string = (string2:s optspace -> s)+:s -> ['string', ''.join(s)]

hexdigit     = letterOrDigit:x !(self.hex_digits.find(x.lower())):v ?(v >= 0)  -> v
hexlit       = hexlit:n hexdigit:d                                             -> (n * 16 + d)
             | hexdigit
number       = "0x" hexlit:n                                                   -> ['hexnumber', n]
             | digit+:ws ('.' digit+:fs                                        -> ['number', float('%s.%s' % (''.join(ws), ''.join(fs)))]
                         | -> ['number'])                                      -> ['number', int(''.join(ws))]

innercsv :rule = optspace (apply(rule):e optspace ',' optspace -> e)*:es (?(rule != 'tupleexpr' or len(es)) optspace apply(rule):l !(es.append(l)))? optspace -> es
csv :rule = !(self.enter_paren()) innercsv(rule):es !(self.leave_paren()) -> es
list  = '[' csv('expr'):v       ']' -> ['list'] + v
tuple = '(' csv('tupleexpr'):v  ')' -> ['tuple'] + v
dict  = '{' csv('dictexpr'):v   '}' -> ['dict'] + v
set   = '{' csv('expr'):v       '}' -> ['set'] + v

tupleexpr = expr
dictexpr  = string:k optspace ':' optspace expr:v -> ['dictkv', k, v]

ifexpr = innerifexpr:t mandspace "if" mandspace innerifexpr:cond mandspace "else" mandspace expr:f -> ['ifexpr', cond, t, f]

if    = "if" mandspace expr:cond optspace ':' block:body elif*:ei else?:e -> ['if', [cond, body]] + [ei] + ([e] if e else [])
elif  = emptyline* indentation "elif" mandspace expr:cond optspace ':' block:body -> [cond, body]
else  = emptyline* indentation "else" optspace ':' block:body -> body

while = "while" mandspace expr:cond optspace ':' block:body -> ['while', cond, body]

for   = "for" mandspace name:var mandspace "in" mandspace expr:data optspace ':' block:body -> ['for', var, data, body]

def   = !(self.get_indent()):i "def" mandspace !(self.indent_stack.append(i)) name:name optspace '(' csv('name'):args ')' optspace ':' block:body !(self.indent_stack.pop()) -> ['func', name, args, body]
deflambda = !(self.get_indent()):i "def" ~~(hspace | '(') !(self.enter_deflambda(i)) optspace '(' csv('name'):args ')' optspace ':' block:body !(self.leave_deflambda()) -> ['func', None, args, body]
lambda = "lambda" mandspace csv('name'):args optspace ':' expr:e -> ['func', None, args, [e]]

try = "try" optspace ':' block:body
      emptyline* indentation "except" mandspace name:err optspace ':' block:errbody
      (emptyline* indentation "finally" optspace ':' block)?:finbody
      -> ['try', body, err, errbody] + ([finbody] if finbody else [])
