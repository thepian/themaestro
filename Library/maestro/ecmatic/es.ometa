//
// Comments and Spacing
//
hspace    = ' ' | '{HT}' | '{VT}' | '{FF}' | '{nbsp}' | '{BOM}' | '{zwj}' | '{zwnj}'
vspace    = ('{CR}':c '{LF}':l -> c+l) | '{CR}' | '{LF}' | '{LS}' | '{PS}'
tail      = hspace+:hs -> [''.join(hs)]
          | end -> []

line_rest = (~vspace :x)*:x (vspace:x |end) -> ''.join(x)

comment  = "//" (~end ~vspace :c)*:c -> [ 'comment', ''.join(c) ]

mlcomment = "/*" something_star_no_slash*:ssns something_without_star:ws "*/" -> ['mlcomment', ''.join(ssns + [ws])]
something_star_no_slash = (~'*' anything)*:ct '*':ct2 ~'/' -> ''.join(ct + [ct2])
something_without_star = (~'*' anything)*:ws -> ''.join(ws)

slcomment = "/*" hsomething_star_no_slash*:ssns hsomething_without_star:ws "*/" -> ['slcomment', ''.join(ssns + [ws])]
hsomething_star_no_slash = (~'*' ~vspace anything)*:ct '*':ct2 ~'/' -> ''.join(ct + [ct2])
hsomething_without_star = (~'*' ~vspace anything)*:ws -> ''.join(ws)

opt_hspan = (hspace | comment | mlcomment)*
opt_vspan = (vspace | hspace | comment | mlcomment)*



//
// Literals
//
name_start = letter | '$' | '_'
name_rest = name_start | digit
iname = name_start:s name_rest*:r -> s + ''.join(r)
isreserved :x = ?(self.is_reserved(x))
name = iname:n ~isreserved(n)  -> n

string3 :e = match_string(e) (~(match_string(e)) anything)*:c match_string(e) -> e + ''.join(c) + e
string2 = string3('"') | string3("'")
string = (string2:s -> s)+:s -> ''.join(s)

hexdigit = letterOrDigit:x !(self.hex_digits.find(x)) -> x

number   = "0x" hexdigit+:d               -> '0x' + ''.join(d)
         | "0X" hexdigit+:d               -> '0X' + ''.join(d)
         | digit+:ws '.' digit+:fs 'e'    -> '%s.%se' % (''.join(ws), ''.join(fs))
         | digit+:ws '.' digit+:fs 'E'    -> '%s.%sE' % (''.join(ws), ''.join(fs))
         | digit+:ws '.' digit+:fs        -> '%s.%s' % (''.join(ws), ''.join(fs))
         | '.' digit+:fs 'e'              -> '.%se' % ''.join(fs)
         | '.' digit+:fs 'E'              -> '.%sE' % ''.join(fs)
         | '.' digit+:ws				  -> '.%s' % ''.join(ws)
         | digit+:ws                      -> ''.join(ws)

regex = regex_empty | regex_nonempty

regex_empty = '/' '/' regexFlags:f -> '//'+f  
regex_nonempty = '/' regexBody:b '/' regexFlags:f -> '/' + b + '/' + f

regexFlags = letter*:l -> ''.join(l)
regexBody = (regexEscape | untilEndRegex)+:p -> ''.join(p)
regexEscape = '\\' (~vspace anything):c -> '\\' + c
untilEndRegex = (~('\\' | '/') anything)+:c -> ''.join(c)

InObjectText = hspace | vspace | comment | mlcomment
property_literal_single = string3("'"):key InObjectText*:pre ":" InObjectText*:post (PrimaryExpression):val -> self.ast("key_value", key, val, quote="'", pre_colon=pre, post_colon=post)
property_literal_double = string3('"'):key InObjectText*:pre ":" InObjectText*:post (PrimaryExpression):val -> self.ast("key_value", key, val, quote='"', pre_colon=pre, post_colon=post)
property_literal_name = iname:key InObjectText*:pre ":" InObjectText*:post (PrimaryExpression):val -> self.ast("key_value", key, val, pre_colon=pre, post_colon=post)
property_literal = property_literal_name | property_literal_single | property_literal_double

ArrayLiteral = "[" (hspace | vspace | comment | mlcomment | PrimaryExpression | ",")*:entries "]" -> self.ast_list("ArrayExpr",entries)

ObjectLiteral = "{" (InObjectText | PropertyLiteral | ",")*:entries "}" -> self.ast_list("ObjectExpr",entries)


literal = "undefined" |  "null" | "true" | "false" | string | number | regex

//
// Expressions
//
innercsv :rule = (apply(rule) | ',')*:es 
csv :rule = !(self.enter_paren()) innercsv(rule):es !(self.leave_paren()) -> es


# inline function void
# conditional ?:
# operators: single, combo, assignments
# lhs expr: just that, call, index, this
# simple expression: obj array lit space comment ()

simple_expr = ObjectLiteral | ArrayLiteral | literal | comment | slcomment | mlcomment | hspace

expr = (literal | ass_ops | dbl_ops | ops | "=" 
     | name 
     | comment | slcomment| mlcomment | hspace | vspace)+:e -> e

ass_ops = "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "~=" | "<<=" | ">>="
dbl_ops = "||" | "&&" | "<<" | ">>" | ">=" | "!=" | "==" | "<=" 
ops = "." | "+" | "-" | "~" | "!" | "*" | "/" | "%" | "|" | "^" | "&" | "<" | ">"

// ?: vs obj lit

// {} block vs {} literate

// [] () ; ,

args_list = (name | comment | slcomment | mlcomment | hspace | vspace | ",")*

conditional = expr:one "?" expr:two ":" expr:three -> ["conditional", one, two, three]

//
// Top level structure
//
statements = (func_block | conditional 
           | scope_macro
           | square_expr | parenthesis_expr | curly_expr
           | ";" | "," | ":"
           | literal | ass_ops | dbl_ops | ops | "=" 
           | "in" | "instanceof" | "void"
           | iname 
           | comment | slcomment | mlcomment | hspace | vspace)*

func_block = keyword("function"):k opt_vspan:pre_name name?:nm opt_vspan:pre_args "(" args_list:args ")" opt_vspan:post_args "{" statements:s "}" -> ["function", k["prefix"], pre_name, nm, pre_args, args, post_args, s ]
# var_decl = keyword("var"):k opt_vspan:gap -> ["var",k["prefix"], gap]
square_expr = "[" statements:s "]" -> ["square", s]
curly_expr = "{" statements:s "}" -> ["curly", s]
parenthesis_expr = "(" statements:s ")" -> ["parenthesis", s]

scope_macro = "@scope" opt_vspan:span string:path opt_vspan:post_path "{" statements:s "}" -> ["scope", span, path, post_path, s]
define_macro = "@define" opt_vspan:span (iname:n "::" -> n)?:ns name:n "=" expr:ex ";" -> ["define", span, ns, ex]

//
// Output tree
//
statements_out = statement_out*:s -> ''.join(s)
exprs_out = expr_out*:s -> ''.join(s)
exprs_list_out = [ expr_out*:s ] -> ''.join(s)

statement_out = func_out
              | conditional_out
              | square_out | curly_out | parenthesis_out
              | ['try'] -> 'TRY'
              | ['test'] -> 'test'
              | ['pass'] -> ''
              | comment_out
              | hspace | vspace
              | op_out 

expr_out = func_out
         | conditional_out
         | square_out | curly_out | parenthesis_out
         | comment_out
         | hspace | vspace
         | op_out

func_out = ['function' :prefix :pre_name :nm :pre_args :args :post_args :s] 
         -> "%sfunction%s%s%s()%s{%s}" % (''.join(prefix), ''.join(pre_name),(nm or ""), ''.join(pre_args),''.join(post_args),''.join(s)) 

conditional_out = ['conditional' exprs_list_out:one exprs_list_out:two exprs_list_out:three] -> "%s?%s:%s" % (one,two,three)

square_out = ['square' exprs_list_out:s] -> "[" + s + "]"
curly_out = ['curly' exprs_list_out:s] -> "{" + s + "}"
parenthesis_out = ['parenthesis' exprs_list_out:s] -> "(%s)" % s

comment_out = ['comment' :c] -> "//" + c
            | ['mlcomment' :c] -> "/*" + c "*/"
            | ['slcomment' :c] -> "/*" + c "*/"

op_out = anything:op -> op

# if = "if" args statement vspace
#    | "if" args statement ";"
#    |  "if" args block

# stmt = continue | break | return | raise | while | delete | new
#      | if | function | for | try | catch
# 
# continue = keyword("continue"):k              -> ['continue', k["prefix"]]
# break    = keyword("break"):k                 -> ['break', k["prefix"]]
# delete   = keyword("delete"):k  get:x   -> ['delete', k["prefix"], x]
# 
# return = "return" mandspace expr:e -> ['return', e]
#        | "return" optspace ~~(vspace | end) -> ['return']
# raise  = "raise" mandspace expr:e  -> ['raise', e]
# 
# unop  = optspace ('-' | '+' | '~'):op unop:e -> ['unop', op, e]
#       | callable
# 
# callable = optspace
#          ( new
#          | get
#          )
# 
# slice = expr?:start optspace ':' optspace expr?:end -> ['slice', start, end]
#       | expr:e -> e
# 
# get = get:obj optspace '.' optspace name:n           -> ['getattr', obj, n]
#     | get:obj optspace '[' !(self.enter_paren()) slice:s !(self.leave_paren()) ']' -> ['getitem', obj, s]
#     | get:obj optspace '(' csv('expr'):params ')'    -> ['call', obj, params]
#     | immediate
# 
# immediate = number
#           | string
#           | list
#           | tuple
#           | dict
#           | set
#           | name
#           | '(' !(self.enter_paren()) expr:ix optspace ')' !(self.leave_paren()) -> ix
# 
# new = "new" mandspace get:c -> ['new', c]
# 	
# innercsv :rule = optspace (apply(rule):e optspace ',' optspace -> e)*:es (?(rule != 'tupleexpr' or len(es)) optspace apply(rule):l !(es.append(l)))? optspace -> es
# csv :rule = !(self.enter_paren()) innercsv(rule):es !(self.leave_paren()) -> es
# list  = '[' csv('expr'):v       ']' -> ['list'] + v
# tuple = '(' csv('tupleexpr'):v  ')' -> ['tuple'] + v
# dict  = '{' csv('dictexpr'):v   '}' -> ['dict'] + v
# set   = '{' csv('expr'):v       '}' -> ['set'] + v
# 
# tupleexpr = expr
# dictexpr  = string:k optspace ':' optspace expr:v -> ['dictkv', k, v]
# 
# ifexpr = innerifexpr:t mandspace "if" mandspace innerifexpr:cond mandspace "else" mandspace expr:f -> ['ifexpr', cond, t, f]
# 
# if    = "if" mandspace expr:cond optspace ':' block:body elif*:ei else?:e -> ['if', [cond, body]] + [ei] + ([e] if e else [])
# elif  = emptyline* indentation "elif" mandspace expr:cond optspace ':' block:body -> [cond, body]
# else  = emptyline* indentation "else" optspace ':' block:body -> body
# 
# while = "while" mandspace expr:cond optspace ':' block:body -> ['while', cond, body]
# 
# for   = "for" mandspace name:var mandspace "in" mandspace expr:data optspace ':' block:body -> ['for', var, data, body]
nil = "nil"

