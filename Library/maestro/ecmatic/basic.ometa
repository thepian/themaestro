blocks = (vspace | comment | mlcomment | annotation)*

hspace    = ' ' | '\t'
vspace    = '\n'

comment  = "//" line_rest:c -> ['comment', c]

mlcomment = "/*" something_star_no_slash*:ssns something_without_star:ws "*/" -> ['mlcomment', ''.join(ssns + [ws])]

something_star_no_slash = (~'*' anything)*:ct '*':ct2 ~'/' -> ''.join(ct + [ct2])
something_without_star = (~'*' anything)*:ws -> ''.join(ws)

emptyline = hspace* ('\\' | comment)?:c vspace

line_rest = (~vspace :x)*:x -> ''.join(x)

name_start = letter | '?' | '!'
name_rest = name_start | digit
iname = name_start:s name_rest*:r -> s + ''.join(r)
isreserved :x = ?(self.is_reserved(x) or x == "null" or x == "true" or x == "false")
name = iname:n ~isreserved(n)  -> n

annotation = annotation_no_params | annotation_params
annotation_no_params = '@' name:n "()"? (';' | vspace | end) -> ['annotation', n]
annotation_params = '@' name:n spaces '(' (~')' anything)*:params ')' (';' | vspace | end) -> ['annotation', n,''.join(params)]


Keyword = ("break" | "do" | "instanceof" | "typeof" | "case" | "else" | "new" | "var" | "catch"
		| "finally" | "return" | "void" | "continue" | "for" | "switch" | "while" | "debugger" 
		| "function" | "this" | "with" | "default" | "if" | "throw" | "delete" | "in" | "try")
		:kwname -> kwname

Punctuator = ">>>="
           | ">>=" | ">>>" | "===" | "!==" | "<<="
           | "+="  | "-="  | "*="  | "%=" | ">="
           | "=="  | "!="  | "++"  | "--" | "<<"
           | ">>"  | "<="  | "&="  | "|=" | "^="
           | "&&"  | "||"
           | '{'     | '}'     | '('     | ')'    | '['   | ']'
           | '.'     | ';'     | ','     | '<'    | '>'   | '!'
           | '~'     | '='     | '&'     | '|'    | '^'   | '?'
           | ':'     | '*'     | '%'     | '+'    | '-'
DivPunctuator = "/=" | '/'

WhitespaceOrLineTerminator = anything:x ?(ucSpacesRE.match(x)) -> x

skip = (WhitespaceOrLineTerminator | mlcomment)*
skipNoLine = (Whitespace | SingleLineComment | MultiLineCommentNoNL)*
skipToEnd = skip end

k :expected = skip Keyword:lexed ?(expected is lexed) -> expected

sc = skipNoLine ';' || skipNoLine (scanLineTerminator || end || ~~'}')

program = (sourceElements | empty -> []):src skipToEnd -> src 

sourceElements = sourceElement*:e ->  e

sourceElement = functionDeclaration | emptyStatement

emptyStatement = ";" -> self.ast("empty")

functionDeclaration = token("function") skip name:name skip "(" (~')' anything)*:args ")" skip 
						"{" sourceElements:body "}" -> self.ast("func", name, ''.join(args), body)



scanLineTerminator = LineTerminator || ~MultiLineCommentNoNL MultiLineComment

scanPunctNoLineTerminator :expected = skipNoLine  (Punctuator || DivPunctuator):lexed ?(expected is lexed) -> expected

scanLiteral = skip Literal:l -> l

scanDirective = skip ~~(RawStringLiteral):raw StringLiteral:l -> {value:l.value, directive:raw}


Block = "{" (SourceElements | empty -> []):stmts "}" -> ast(self.position, "BlockStmt",{},stmts) 

StatementList = StatementList:stmts Statement:stmt -> stmts + [ stmt ] | Statement:stmt -> [stmt]

Statement = Block || EmptyStatement

EmptyStatement = ";" -> ast(self.position, "EmptyStmt",{},[])

FunctionDeclaration = k("function") name:patt
                      "(" (FormalParameterList | empty -> []):formals ")"
                      "{" FunctionBody:body "}" -> ast(self.position, "FunctionDecl",{}, [patt,
                                  ast(self.position, "ParamDecl",{},formals)] + body)

FunctionExpression = k("function") name:patt
                     "(" (FormalParameterList | empty -> []):formals ")"
                     "{" FunctionBody:body "}" ->
                     ( ast(_fromIdx, "FunctionExpr",{}, [patt,
                                 ast(self.position, "ParamDecl",{},formals)] + body) )
                   || k("function") "(" (FormalParameterList | empty -> []):formals ")"
                     "{" FunctionBody:body "}" -> ast(self.position, "FunctionExpr",{}, [emptyAst(),
                                 ast(self.position, "ParamDecl",{},formals)] + body) 

FormalParameterList = FormalParameterList:formals "," FormalParameter:formal -> formals + [ formal ]
                    | FormalParameter:formal -> [formal]

FormalParameter = name

FunctionBody = (DirectivePrologue | empty -> []):prologue
                 (SourceElements | empty -> []):src -> prologue + src


Program = (DirectivePrologue | empty -> []):prologue
            (SourceElements | empty -> []):src skipToEnd -> ast(self.position, "Program",{},prologue + src ) 

SourceElements = SourceElements:elts SourceElement:e ->  elts + [e]  | SourceElement:e -> [e]

SourceElement = Declaration || Statement

Declaration = FunctionDeclaration

DirectivePrologue = DirectivePrologue:p Directive:d ->  p + d | Directive:d -> [d]

Directive = scanDirective:dir sc -> ast(_fromIdx, 'PrologueDecl',dir,[]) 


